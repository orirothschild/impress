<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Docker..What Are You? | by Ori Rothschild</title>
    
    <meta name="author" content="Henrik Ingo" />
    <link href="css/classic-slides.css" rel="stylesheet" />
    
</head>
<body class="impress-not-supported">
<div class="fallback-message">
    <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
    <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
</div>


<div id="impress" data-transition-duration="1000">

    <div id="overview" class="step" data-x="3000" data-y="1500" data-z="-1" data-scale="10"
         style="pointer-events: none;">
        <img src="./images/docker-logo.png" alt="Large tree" width="1600"
            style="position: inherit; top: -600px; left: -200px" />
            
    </div>
    
    <div class="step title" data-x="-1750" data-y="5200" data-scale="2.5" id="title">
        <h1>What is it, exactly?</h1>
        <h2>by Ori Rothschild<br /><br />
        <br />
        </h2>
        <p style="text-align: right;"><small>v2</small></p>
    </div>
     
    <div id="overview" class="step" data-x="3000" data-y="1500" data-z="-1" data-scale="10" data-autoplay="0.1">
    </div>

    <div class="step" data-x="650" data-y="5000" data-rotate-y="0" data-scale="1"
         id="topics">
        <h1>The questions we shall tackle</h1>
        <ol>
            <li>What is Docker?</li>
            <li>Why use it?</li>
            <li>How does it work?</li>
            <li>What is an Images?</li>
            <li>What is a container?</li>
            <li>What is isolation?</li>
        </ol>
    </div>
 
    
    <div id="big" class="step" data-x="5000" data-y="10500" data-z="100" data-scale="20">
            <h5>Docker is <b>big</b> </h5>
        </div>
       
        <div id="tiny" class="step" data-x="3150" data-y="10000"  data-scale="1">
           <p>but in a  <b>nutshell</b> Docker makes it really easy to isntall and run software without worrying about setups or <b>dependencies</b></p>
       </div>

    <div class="step" data-rel-x="-150" data-rel-y="1700" data-rel-z="-10" data-rotate-y="180" id="h_ingo">

        
        <img src="images/diagrams-05 - redis.png" width="500" height="450" 
            style="position: inherit; top: -420px; left: 450px" />
        <img src="images/eco.jpg"  width="400" height="300"
        style="position: inherit; top: 130px; left: 420px" />

    </div>
    
    <div class="step" style="text-align: center"data-rel-z="10" data-rel-x="-1100" data-rel-y="-3000" data-rotate-y="90" data-scale="0.8">
              <div id="imagination" data-scale="2">
          <p>the single file with all the deps and config required to run a program is called an <b>image</b></p>
            </div>
            <div class="arrow_box" >
                    <h4 style="text-align:center">Image (running instances of an image is called a contianer)</h4>
                </div>
              <div id="demo" data-rel-z="10" data-x="3350" data-y="100000" >container</div>
              <div id="demo" data-rel-z="10" data-x="3350" data-y="100000"margin-top="7cm" >container</div>     
           </div>

    <div class="step" data-rel-x="-2900" data-rel-y="250" data-scale="1.2">
            <div class="arrow_down" position="relative">
                    <h4 style="text-align:center">Docker <strong>Client</strong><p>tool that we are going to issue commands to</p></h4>
                </div>

            <div class="arrow_up"margin-top="12px"position="-600px">
                    <h4 style="text-align:center">Docker <strong>Deamon</strong><p>tool that is responsible for running images,containers,etc</p></h4>
                </div>
    </div>


    
    
    <div class="step"  data-rotate-y="25"  data-rotate-x="12">
        
        <img src="images/diagrams-08 - flow.svg" width="1300" height="650" 
        style="position: inherit; top: -330px; left: -50px" />
        <div class="arrow_up"style=" position:bottom;bottom:-300px; ;right:150px;">
                    <h4 style="text-align:center">Docker run<strong> Flow</strong></h4>
                </div>

    </div>

    <div class="step">
        <h1>At scale, ops become more interesting...</h1>
        <ul>
        <li>How long does it take to copy 1-2 TB over the network?</li>
        <li>How long does it take to rebuild all indexes?</li>
        <li>While DBA doesn't need to do anything but wait, it's not fun to wait week(s)</li>
        <li>If there's network glitch during initial sync, start from scratch</li>
        <li>Note: Manual workarounds existed to make this faster, but sometimes they can't be used (mmapv1->wiredTiger sync)</li>
        </ul>
    </div>

    <div id="balancerRecap" class="step" style="text-align: center" data-x="3500" data-y="4350" data-scale="2">
        <h1>Balancer recap</h1>
        <img src="images/balancer.svg" alt="MongoDB sharded cluster with a chunk migration happening"/>
    </div>

    <div class="step" data-rel-x="800" data-rel-y="200">
        <h1>A MongoDB cluster:</h1>
        <ul>
            <li>Consists of N shards (partitions)</li>
            <li>...which consist of chunks (mini-partitions)</li>
            <li>...each chunk contains ~ 64 MB of data (by default)</li>
            <li><em><a href="https://docs.mongodb.com/manual/tutorial/manage-sharded-cluster-balancer/">The Balancer</a></em> tries to keep an even number of chunks on each shard</li>
            <li>If you configured <a href="https://docs.mongodb.com/manual/tutorial/manage-shard-zone/">zones</a> the balancer tries to move chunks to the zone they belong</li>
        </ul>
    </div>

    <div class="step" id="singleton"  data-x="6600" data-y="3850" data-scale="2">
        <h1>2. Moving balancer to config server</h1>
        <img width="300" src="images/balancer.svg" alt="MongoDB sharded cluster with a chunk migration happening"
             class="right" />

        <ul class="substep">
        <li>Used to run on a mongos</li>
        <li>Users have 100+ mongoses, but only 1 of them can run balancer</li>
        <li>Led to unnecessary stress competing for the balancer lock</li>
        <li>There's only 1 primary config server => No locking needed</li>
        </ul>
    </div>

    <div class="step" id="compression"  data-rel-x="0" data-rel-y="-1200" data-scale="2">
        <h1>3. Compression of Wire Protocol (<a href="https://jira.mongodb.org/browse/SERVER-3018">SERVER-3018</a>)</h1>

        <ul>
        <li><code>--networkMessageCompressors=snappy</code></li>
        <li>Big deal over WAN</li>
        <li>Snappy compression usually 4-5x &amp; light on CPU</li>
        <li>I have no test results, sorry :-(</li>
        </ul>
    </div>

    <div class="step title" id="throttling" data-rotate="-90" data-x="9200" data-y="1800" data-scale="2">
        <h1>4. Balancer throttling</h1>
    </div>

    <div class="step" data-rel-x="1000" data-rel-y="500" data-rotate="-70">
        <h1>Throttling &amp; balancer</h1>
        <ul>
        <li>Balancer is a background process</li>
        <li>Until MongoDB 3.2:
            <ul>
                <li>Throttle to limit overhead to application queries. (Important with MMAPv1 engine.)</li>
                <li>Only 1 migration concurrently.</li>
                <li><strong>w:2</strong> write concern used <strong>for each</strong> document insert &amp; delete.</li>
            </ul>
        </li>
        <li>New in MongoDB 3.4:
            <ul>
                <li>Runs on the primary config server</li>
                <li>No throttling for WiredTiger</li>
                <li>1 migration <em>per shard</em> concurrently (max = shards/2)</li>
            </ul>
        </li>
        <li>Hardwired <strong>w:majority</strong> at end of insert / delete of chunk</li>
    </div>

    <div class="step" data-rel-x="-300" data-rel-y="-1500" data-rotate="-130">
        <h1>Configurability of the balancer</h1>
        <ul>
        <li>Users need to configure both ways:
           <ul>
           <li>Balancer is causing too much overhead: it should run less</li>
           <li>Need to quickly move data to other shards: it should run faster</li>
           </ul>
        </li>
        <li>Solutions available:
            <ul>
                <li><a href="https://docs.mongodb.org/manual/tutorial/configure-sharded-cluster-balancer/#schedule-a-window-of-time-for-balancing-to-occur">Set balancer time window</a></li>
                <li>Since v3.0:<br /><a href="https://docs.mongodb.org/manual/tutorial/configure-sharded-cluster-balancer/#secondary-throttle">Configure _secondaryThrottle &amp; writeConcern</a></li>
            </ul>
        </li>
        </ul>
           
    </div>

    <div class="step" data-rel-x="-1000" data-rel-y="-600" data-rotate="-160">
        <h1 style="text-align: left;">Example</h1>
<pre>
use config
db.settings.update(
   { "_id" : "balancer" },
   { $set : { "_secondaryThrottle" : false ,
              "writeConcern": { "w": 1 } } },
   { upsert : true }
)
</pre>
    </div>

    <div id="benchmark" class="step" data-rel-x="-1200" data-rel-y="-900" data-rotate="-180">
        <h1>Let's benchmark this</h1>
        <p>YCSB load with 30 threads x 100 batchsize</p>
        <p>3 shards * 3 replicas</p>
        <p>MongoDB 3.2.4</p>
        <p>AWS c3.large with standard EBS*</p>
        <p>Throughput: 5k - 25k docs / sec **</p>
        <p>&nbsp;</p>
        <p style="line-height: 0.5em;"><small>*) Test is short enough that boosting provides good EBS perf.</small><br />
           <small>**) This is a very low throughput, which is the point of this test.<br />
           This test demonstrates a common effect where sharded clusters become unbalanced<br />
           even with a simple insert workload when not using hashed shard key.</small></p>
        <div class="notes">
<pre>
$ ./bin/ycsb load mongodb-async -s -P workloads/throttlingtest -threads 30
$ cat workloads/throttlingtest 
mongodb.url=mongodb://throttl-4.henrikingo3.8300.mongodbdns.com:27017/test
mongodb.batchsize=100
recordcount=50000000


operationcount=1000
workload=com.yahoo.ycsb.workloads.CoreWorkload

readallfields=true

readproportion=0.5
updateproportion=0.5
scanproportion=0
insertproportion=0

requestdistribution=zipfian
</pre>
        </div>
    </div>

    <div class="step" data-rel-x="0" data-rel-y="-900" data-rotate="-180">
       <img src="images/ycsb-load-1.png" />
    </div>

    <div class="step" data-rel-x="0" data-rel-y="-900" data-rotate="-180">
       <img src="images/ycsb-load-2.png" />
    </div>

    <div class="step" data-scale="3" data-rel-y="-1400" data-rotate="-180">
        <h1>What did we learn?</h1>
        <ul>
        <li>A naive insert / load test is not distributed well over all shards</li>
        <li>With throttling on, balancer will not keep up = unbalanced cluster</li>
        <li>With throttling off, balancer will keep up
            <ul>
            <li>Note: this is still an inefficient way of loading data into MongoDB</li>
            <li>Point is just that the balancer is able to keep up</li>
            </ul>
        </li>
        <li>The default in MongoDB 3.4 is <em>throttling off</em></li>
        </ul>
    </div>

    <div class="step title" id="parallel" data-rel-x="-4000" data-rel-y="0" data-rotate="-230">
        <h1>5. Parallel chunk migrations</h1>
    </div>

    <div class="step" style="text-align: center" data-rel-x="-4000" data-rel-y="-300" data-rotate="-280">
        <img src="images/balancer-new-shard.svg" alt="MongoDB sharded cluster with a chunk migration happening"/>
        <p>As with initial sync, adding a new shard to a cluster is easy. Just add an empty shard, and the balancer starts moving data to it.</p>
    </div>

    <div class="step" style="text-align: center" data-rel-x="-4000" data-rel-y="-300" data-rotate="-280">
        <h1>At scale, ops become more interesting...</h1>
        <img src="images/balancer-scale-10.svg" alt="MongoDB sharded cluster with 10 shards"
             style="position: inherit; top: 40px; left: 340px"/>
        <img src="images/balancer-scale-32.svg" alt="MongoDB sharded cluster with 20 shards and 1 migration happening"
             style="position: inherit; top: 40px; left: 340px" class="substep" />
        <p class="substep" style="margin-top: 260px;"><strong>MongoDB 3.2:</strong> Only 1 migration at a time.<br />
                                                      All new shards but one remain empty. <br />
                                                      The DBA just needs to wait... but how long?</p>
        <p class="substep"><strong>MongoDB 3.4:</strong> N/2 migrations at a time.<br />
                           Double nr of shards in same time as adding 1 shard.</p>
        <img src="images/balancer-scale-34.svg" alt="MongoDB sharded cluster with 20 shards and 10 migrations happening"
             style="position: inherit; top: 40px; left: 340px" class="substep" />
    </div>

    <div class="step" id="future" data-x="-30000" data-y="9000" data-z="8000" data-rotate-x="-95" data-rotate-y="-55" data-transition-duration="5000">
        <h1>Future work</h1>
        <ul>
        <li><a href="https://jira.mongodb.org/browse/SERVER-27760"><strike>SERVER-27760</strike></a> Smarter, stateful orphan deletion (3.6)</li>
        <li><a href="https://jira.mongodb.org/browse/SERVER-5931"><strike>SERVER-5931</strike></a> Secondary reads in a sharded cluster (3.6)</li>
        <li><a href="https://jira.mongodb.org/browse/SERVER-20739">SERVER-20739</a> Make initial sync resilient to network/other failures</li>
        <li><a href="https://jira.mongodb.org/browse/SERVER-9287">SERVER-9287</a> Split chunks on mongod, not mongos</li>
        <li>Maybe make chunk migrations even faster?
            <ul>
            <li>Bulk inserts</li>
            <li>More than one per shard</li>
            </ul>

</div>

<div id="impress-toolbar"></div>
<div id="impress-help"></div>

<script type="text/javascript" src="js/impress.js"></script>
<script>impress().init();</script>
</body>
</html>
